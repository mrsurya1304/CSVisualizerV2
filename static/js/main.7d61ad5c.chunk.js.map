{"version":3,"sources":["Home/home.jsx","PathfindingComponents/Pathfinder/Node/node.jsx","PathfindingComponents/algorithms/algorithms.jsx","PopupComponent/Popup.js","PathfindingComponents/Pathfinder/pathfinder.jsx","SortingComponents/Algorithm-files/mergesort.jsx","SortingComponents/Sortingvisualizer/Sortingvisualizer.jsx","SortingComponents/Algorithm-files/bubblesort.jsx","App.js","reportWebVitals.js","index.js"],"names":["Home","history","useHistory","className","onClick","push","node","props","state","this","col","isfinish","isstart","iswall","onMouseDown","isvisited","onMouseEnter","onMouseUp","row","extraClassName","id","Component","dijkstra","grid","startnode","endnode","visitednodesinorder","distance","unvisitednodes","nodes","getnodes","length","sortnode","closestnode","shift","Infinity","updateneighbors","notinunvisited","neighbor","manhattandistance","Math","abs","sort","nodeA","nodeB","neighbors","getneighbors","previousnode","filter","getnodesinshortestpath","nodesinshortestpath","currentnode","unshift","Popup","trigger","handleclose","children","snr","randomint","snc","enr","enc","dijkstravisited","dijkstrashortestpath","astarvisited","astarshortestpath","pathfinder","changestate","setState","popupstate","mouseispressed","getgrid","getresults","a","b","totaldistance","astar","document","getElementById","disabled","buttonid","newgrid","gridwithwalltoggled","i","setTimeout","animateshortestpath","disablebutton","animate","innerHTML","map","rowidx","nodeidx","handlemousedown","handlemouseenter","handlemouseup","visualizedijkstra","visualizeastar","cleargrid","window","location","reload","cellPadding","currentrow","createnode","isshortest","min","max","floor","random","slice","newnode","mergeSort","array","animations","auxarray","mergeSortHelper","mainarray","startidx","endidx","mididx","j","k","comparisons","domerge","bubblesorted","mergesorted","Sortingvis","duparray","resetArray","style","height","arraybars","getElementsByClassName","num","bar1idx","bar2idx","bar1style","bar2style","color","backgroundColor","swaps","temp","bubbleSort","tempheight","value","idx","getoriginalArray","React","App","exact","path","to","component","Pathfinder","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.7d61ad5c.chunk.js","sourcesContent":["import React from \"react\";\r\nimport './home.css';\r\nimport { useHistory } from 'react-router-dom';\r\n\r\nexport default function Home(){ //Homepage\r\n    let history = useHistory(); //To append to search bar\r\n    return (\r\n      <div>\r\n      <h1>CS Visualiser</h1>\r\n      <p className=\"intro\">Welcome to the CS visualiser. This tool is aimed to promote visual learning and hopefully \r\n        give you a deeper insight into the world of algorithms. \"A picture is worth a thousand words\" \r\n        with that being said enjoy, learn and play around with our application <br></br>\r\n      </p>\r\n      <button onClick={() => {history.push('/pathfinding')}}>Path finding visualizer</button>\r\n      <button onClick={() => {history.push('/sorting')}}>Sorting algorithm visualizer</button>\r\n\r\n      </div>\r\n    )\r\n\r\n    \r\n}","import React,{ Component } from \"react\";\r\nimport './node.css';\r\n\r\nexport default class node extends Component {  //A node is a single cell in our grid\r\n    constructor(props){\r\n        super(props);\r\n        this.state={};\r\n    }\r\n\r\n    render(){ //All properties of our node\r\n        const {\r\n            col,\r\n            isfinish,   //finish node property\r\n            isstart,    //start node property\r\n            iswall= false,  //wall property\r\n            isvisited = false,  //visited node\r\n            onMouseDown,    //mouse events for walls\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            row,}= this.props;\r\n\r\n        const extraClassName = isfinish //finish node\r\n            ? 'node-finish'\r\n            : isstart   //start node\r\n            ? 'node-start'\r\n            : iswall    //node which is a wall\r\n            ? 'node-wall'\r\n            :'';\r\n\r\n        return(\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row,col)} //To draw walls\r\n                onMouseEnter={() => onMouseEnter(row,col)}\r\n                onMouseUp={() => onMouseUp()}></div>\r\n        );\r\n    }\r\n}\r\n","export function dijkstra(grid, startnode, endnode){ //Dijkstras algorithm\r\n    \r\n    const visitednodesinorder=[]; //Array to store visited nodes in order\r\n    if(!startnode || !endnode || startnode===endnode){  //If no start node or no end node or if both are equal we return from the function\r\n        return false;\r\n    }\r\n    startnode.distance=0; //Initialising start node distance to 0\r\n    const unvisitednodes=getnodes(grid); //Getting all nodes from grid and marking as unvisited\r\n    while(!!unvisitednodes.length){\r\n        sortnode(unvisitednodes);   //Sorting unvisited nodes by distance\r\n        const closestnode=unvisitednodes.shift();   //Getting nearest nodes\r\n        \r\n        if(closestnode.iswall) continue;    //If any nearest node is a wall we skip it\r\n        if(closestnode.distance===Infinity) return visitednodesinorder; //If no posibility for path to end node we return the visited nodes\r\n\r\n        closestnode.isvisited=true; //Closest nodes are marked as visited\r\n        visitednodesinorder.push(closestnode);//Pushing into our array\r\n        if(closestnode===endnode) return visitednodesinorder; //If we reach the end node we return the visited nodes\r\n        updateneighbors(closestnode,grid);\r\n    }\r\n}\r\n\r\nexport function astar(grid, startnode, endnode){    //A* algorithm\r\n    const visitednodesinorder=[];   //Array to store visited nodes in order\r\n    const unvisitednodes=[];    ////Array to store unvisited nodes\r\n    if(!startnode || !endnode || startnode===endnode){  //If no start node or no end node or if both are equal we return from the function  \r\n        return false;\r\n    }\r\n    startnode.distance=0;   //Initialising start node distance to 0\r\n    unvisitednodes.push(startnode);\r\n\r\n    while(unvisitednodes.length!==0){\r\n        unvisitednodes.sort((a,b)=> a.totaldistance - b.totaldistance); //Sorting unvisited nodes by distance\r\n        let closestnode = unvisitednodes.shift(); //Getting the closest node\r\n        if(closestnode === endnode) return visitednodesinorder; //If the closest node is the end node we return the visited nodes\r\n\r\n        closestnode.isvisited = true;   //We mark the closest node as visited\r\n        visitednodesinorder.push(closestnode);      //We push it into the visited nodes array\r\n\r\n        let neighbors = getneighbors(closestnode,grid); //Getting neighboring nodes\r\n        for(let neighbor of neighbors){ //For each neighbor\r\n            let distance = closestnode.distance + 1;    //Updating the distance\r\n            if(notinunvisited(neighbor,unvisitednodes)){    //If neighbor is visited\r\n                unvisitednodes.unshift(neighbor);   //Remove from unvisited nodes array\r\n                neighbor.distance = distance;   //Computing the distance\r\n                neighbor.totaldistance = distance + manhattandistance(neighbor, endnode); //Adding the manhattan distance so we can compute which neighbor goes towards the end node \r\n                neighbor.previousnode = closestnode; //Setting the previous node to our now computed closest node\r\n            }\r\n        }\r\n    }\r\n    return visitednodesinorder;\r\n    \r\n}\r\n\r\nfunction notinunvisited(neighbor, unvisitednodes){ //Method to check if a node is in the unvisited node array\r\n    for(let node of unvisitednodes){\r\n        if(node.row === neighbor.row && node.col === neighbor.col){\r\n            return false\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction manhattandistance(neighbor, endnode)   //Method to compute manhattan distance\r\n{\r\n    let d = Math.abs(endnode.row-neighbor.row)+Math.abs(endnode.col-neighbor.col);\r\n    return d;\r\n}\r\n\r\nfunction sortnode(unvisitednodes){  //Method to sort the nodes according to their distance\r\n    unvisitednodes.sort((nodeA,nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateneighbors(node, grid){   //Method to update distances and previous node to each neighbor\r\n    const neighbors= getneighbors(node,grid);\r\n    for(const neighbor of neighbors){\r\n        neighbor.distance=node.distance+1;\r\n        neighbor.previousnode=node;\r\n    }\r\n}\r\n\r\nfunction getneighbors(node, grid){  //Method to retrieve neighboring nodes\r\n    const neighbors =[];\r\n    const {col,row}=node;\r\n    if(row>0) neighbors.push(grid[row-1][col]);\r\n    if(row < grid.length-1) neighbors.push(grid[row+1][col]);\r\n    if(col>0) neighbors.push(grid[row][col-1]);\r\n    if(col < grid[0].length-1) neighbors.push(grid[row][col+1]);\r\n    return neighbors.filter(neighbor => !neighbor.isvisited && !neighbor.iswall);\r\n}\r\n\r\nfunction getnodes(grid){    //Method to get an empty grid\r\n    const nodes=[];\r\n    for(const row of grid){\r\n        for(const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport function getnodesinshortestpath(endnode){    //Method to get the nodes in the shortest path\r\n    const nodesinshortestpath=[];\r\n    let currentnode = endnode;\r\n    while(currentnode !== null){\r\n        nodesinshortestpath.unshift(currentnode);\r\n        currentnode=currentnode.previousnode;\r\n    }\r\n    return nodesinshortestpath;\r\n}","import React from 'react'\r\nimport './Popup.css'\r\n\r\n\r\nfunction Popup(props) { //To render a popup to display information or a manual to the screen\r\n  return (props.trigger) ? (\r\n    <div className='popup'>\r\n        <div className='popup-inner'>\r\n            <button className='close-btn' onClick={props.handleclose}>\r\n                Close\r\n            </button>\r\n            {props.children}\r\n        </div>\r\n    </div>\r\n  ) : \"\";\r\n}\r\n\r\nexport default Popup","import React,{ Component } from \"react\";\r\nimport Node from './Node/node';\r\nimport './pathfinder.css';\r\nimport {dijkstra, astar, getnodesinshortestpath} from '../algorithms/algorithms';\r\nimport Popup from \"../../PopupComponent/Popup\";\r\n\r\nconst snr= randomint(0,19); //Getting a random start node\r\nconst snc=randomint(0,49);\r\nconst enr=randomint(0,19);  //Getting a random end node\r\nconst enc=randomint(0,49);\r\n\r\nvar dijkstravisited= [];  //Dijkstras algorithm visited nodes and shortest path\r\nvar dijkstrashortestpath = [];  \r\nvar astarvisited = [];  //A* algorithm visited nodes and shortest path\r\nvar astarshortestpath = [];\r\n\r\nexport default class pathfinder extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            grid: [],\r\n            mouseispressed: false,\r\n            popupstate: false,\r\n        };\r\n        \r\n    }\r\n\r\n    componentDidMount(){    //Setting grid and getting results of both algorithms after first load\r\n        const grid = getgrid();\r\n        this.setState({grid});\r\n        this.getresults(grid);\r\n    }\r\n\r\n    getresults(grid){   //Method to run algorithms and get visited nodes and shortest path\r\n        const startnode = grid[snr][snc];\r\n        const endnode = grid[enr][enc];\r\n\r\n        astarvisited = astar(grid,startnode,endnode);\r\n        astarvisited.push(endnode);\r\n        astarshortestpath = getnodesinshortestpath(endnode);\r\n        dijkstravisited = dijkstra(grid,startnode,endnode);\r\n        dijkstrashortestpath = getnodesinshortestpath(endnode);\r\n    }\r\n\r\n    cleargrid() //Method to clear the grid (Doesnt clear the wall so algorithms can be compared fairly)\r\n    {\r\n        document.getElementById(\"dijkstra\").disabled = false;\r\n        document.getElementById(\"astar\").disabled = false;\r\n        for(let row=0; row<20;row++){\r\n            for(let col=0; col<50;col++){\r\n                if(document.getElementById(`node-${row}-${col}`).className==='node node-visited' || document.getElementById(`node-${row}-${col}`).className==='node node-shortestpath'){\r\n                    document.getElementById(`node-${row}-${col}`).className='node';\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    disablebutton(buttonid) //Method to disable a button by its id\r\n    {\r\n        document.getElementById(buttonid).disabled = true;\r\n    }\r\n\r\n    handlemousedown(row,col){   //Method to handle mouse click\r\n        const newgrid = gridwithwalltoggled(this.state.grid,row,col);\r\n        this.setState({grid: newgrid, mouseispressed: true});\r\n    }\r\n\r\n    handlemouseenter(row,col){  //Method to draw wall when mouse is over a node\r\n        if(!this.state.mouseispressed) return;\r\n        const newgrid = gridwithwalltoggled(this.state.grid,row,col);\r\n        this.setState({grid: newgrid});\r\n    }\r\n\r\n    handlemouseup() //Method to handle after mouse click\r\n    {\r\n        this.setState({mouseispressed: false});\r\n    }\r\n\r\n    changestate =() =>  //Method to handle the closing of a popup\r\n    {\r\n        this.setState({popupstate: !this.state.popupstate});\r\n    }\r\n\r\n    animate(visitednodesinorder,nodesinshortestpath){   //Method to animate visited nodes in order and shortest path\r\n        for(let i=1; i<=visitednodesinorder.length-1;i++){\r\n            if(i=== visitednodesinorder.length-1){//After visited nodes in order animation\r\n                setTimeout(() => {  //Shortest path animation with timeout of 10 * index\r\n                    this.animateshortestpath(nodesinshortestpath);\r\n                },10*i)\r\n                return;\r\n            }\r\n            setTimeout(() => {  //Visited nodes animation with timeout of 50 * index\r\n                const node=visitednodesinorder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className='node node-visited';\r\n            }, i*10);\r\n        }\r\n    }\r\n\r\n    animateshortestpath(nodesinshortestpath){   //Method to animate the shortest path (Backtracking)\r\n        for(let i=1; i<nodesinshortestpath.length-1;i++){\r\n            setTimeout(() => {//Shortest path nodes set to a different classname to give different styling\r\n                const node= nodesinshortestpath[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className='node node-shortestpath';\r\n            }, 50*i);\r\n        }\r\n    }\r\n\r\n    visualizedijkstra(){    //Method to visualize Dijkstra's algorithm\r\n        this.disablebutton('astar');    //Disabling buttons\r\n        this.disablebutton('dijkstra');\r\n        this.disablebutton('clear');\r\n\r\n        this.animate(dijkstravisited,dijkstrashortestpath); //Animating visited nodes and shortest path\r\n\r\n        document.getElementById('dijkstravisited').innerHTML = dijkstravisited.length-2;    //Setting no of nodes visited and no of nodes in shortest path onto the screen\r\n        document.getElementById('sizeofpath').innerHTML = dijkstrashortestpath.length-2;\r\n\r\n        setTimeout(function () { document.getElementById(\"clear\").disabled = false; }, ((dijkstravisited.length)*10+(dijkstrashortestpath.length)*50)); //Enabling the clear grid button after all animations\r\n    }\r\n\r\n    visualizeastar(){   //Method to visualize A* algorithm\r\n\r\n        this.disablebutton('dijkstra'); //Disabling buttons\r\n        this.disablebutton('astar');\r\n        this.disablebutton('clear');\r\n\r\n        this.animate(astarvisited,astarshortestpath);   //Animating visited nodes and shortest path\r\n\r\n        document.getElementById('astarvisited').innerHTML = astarvisited.length-2;  //Setting no of nodes visited and no of nodes in shortest path onto the screen\r\n        document.getElementById('sizeofpath').innerHTML = astarshortestpath.length-2;\r\n        \r\n        setTimeout(function () { document.getElementById(\"clear\").disabled = false; }, ((astarvisited.length)*10+(astarshortestpath.length)*50));//Enabling the clear grid button after all animations\r\n    }\r\n\r\n    render(){\r\n        const {grid, mouseispressed, popupstate}= this.state; //Setting initial states\r\n\r\n        return( //Grid with random start and end node and buttons for resetting, clearing, manuals and algorithms\r\n                //We also have ability to draw walls\r\n                //There are also metrics for the algorithms in the bottom\r\n          <>\r\n            <div className=\"grid\">\r\n                <h2>Pathfinding Visualizer<br></br></h2>\r\n                {grid.map((row,rowidx)=> {\r\n                    return (\r\n                        <div key={rowidx}>\r\n                        {row.map((node,nodeidx)=>{\r\n                            const {row,col,isfinish, isstart,iswall,isvisited}=node;\r\n                            return (    //Single node in grid with all its properties\r\n                            <Node\r\n                                key={nodeidx}\r\n                                col={col}\r\n                                isfinish={isfinish}\r\n                                isvisited={isvisited}\r\n                                isstart={isstart}\r\n                                iswall={iswall}\r\n                                mouseispressed={mouseispressed}\r\n                                popupstate={popupstate}\r\n                                onMouseDown={(row,col)=> this.handlemousedown(row,col)}\r\n                                onMouseEnter={(row,col)=> this.handlemouseenter(row,col)}\r\n                                onMouseUp= {()=> this.handlemouseup()}\r\n                                row={row}\r\n                            ></Node>\r\n                        );\r\n                        })}\r\n                    </div>\r\n                    );\r\n                })}\r\n            </div>\r\n            <br></br>\r\n            <button id=\"dijkstra\" onClick={() => this.visualizedijkstra()}>\r\n                Dijkstra's Algorithm\r\n            </button>\r\n            <button id=\"astar\" onClick={() => this.visualizeastar()}>\r\n                A* Algorithm\r\n            </button>\r\n            <button id=\"clear\" onClick={this.cleargrid}>Clear grid</button>\r\n            <button id=\"reset\" onClick={() => window.location.reload(false)}>Reset grid</button>\r\n            <button id=\"man\" onClick={this.changestate}>User manual</button>\r\n\r\n            <div className='sorting-metrics'>\r\n                    <table cellPadding={10}>\r\n                        <tr>\r\n                            <th>Dijkstra's</th>\r\n                            <td>Nodes visited:  </td><br/><br/>\r\n                            <td id='dijkstravisited'></td><br/><br/>\r\n                        </tr>\r\n                        <tr>\r\n                            <th>A*</th>\r\n                            <td>Nodes visited: </td><br/><br/>\r\n                            <td id='astarvisited'></td><br/><br/>\r\n                        </tr>\r\n                        <tr>\r\n                            <td>Nodes in shortest path: </td>\r\n                            <td id=\"sizeofpath\"></td>\r\n                        </tr>\r\n                    </table>\r\n                </div>\r\n\r\n            {this.state.popupstate ? //Popup for the user manual\r\n            <Popup trigger={popupstate} handleclose = {this.changestate}>\r\n                <h2>Path finding visualizer tutorial</h2>\r\n                <p>Welcome, This is the path finding visualizer<br></br>\r\n                The start node is highlighted in green<br></br>\r\n                The end node is highlighted in red<br></br>\r\n                You have a button to reset the grid which generates random start and end nodes<br></br>\r\n                There is also a button to clear the grid which erases everything apart from the walls so you can compare algorithms<br/>\r\n                You have algorithm buttons when clicked tries to find the shortest path to the end node<br></br>\r\n                When clicked the nodes that the algorithm visits are colored brown<br></br>\r\n                The shortest path is colored yellow<br></br>\r\n                Observe and learn how each algorithm computes the shortest path<br></br>Enjoy\r\n                </p>\r\n            </Popup>\r\n            :null}\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nconst getgrid=() => {   //Method to get a new empty grid\r\n    const grid=[];\r\n    for(let row=0; row<20;row++){\r\n        const currentrow=[];\r\n        for(let col=0;col<50;col++){\r\n            currentrow.push(createnode(col,row));\r\n        }\r\n        grid.push(currentrow);\r\n    }\r\n    return grid;\r\n};\r\n\r\nconst createnode =(col,row) =>{ //Method to create a single node with the required properties\r\n    return{\r\n        col,\r\n        row,\r\n        isstart: row===snr && col===snc,\r\n        isfinish: row===enr && col===enc,\r\n        distance: Infinity,\r\n        totaldistance: Infinity,\r\n        isshortest: false,\r\n        isvisited: false,\r\n        iswall: false,\r\n        previousnode: null,\r\n        \r\n    };\r\n};\r\n\r\nfunction randomint(min, max)    //Method to get a random value within a range\r\n{\r\n    return Math.floor(Math.random()*(max-min+1)+min);\r\n}\r\n\r\nconst gridwithwalltoggled=(grid,row,col)=> {    //Method to get a grid with walls drawm\r\n    const newgrid = grid.slice();\r\n    const node= newgrid[row][col];\r\n    const newnode= {\r\n        ...node,\r\n        iswall: !node.iswall,\r\n    };\r\n    newgrid[row][col]=newnode;\r\n    return newgrid;\r\n};","export function mergeSort(array){\r\n    const animations =[];  //array to store animations\r\n    if(array.length <=1) return array;  //single element arrays dont need to be sorted\r\n    const auxarray= array.slice();  //Auxilliary array to do the sorting operations\r\n    mergeSortHelper(array,0,array.length-1,auxarray,animations);\r\n    return animations; //Returning the animation array for rendering\r\n}\r\n\r\nfunction mergeSortHelper( //Method to split the array recursively through the middle\r\n    mainarray,\r\n    startidx,\r\n    endidx,\r\n    auxarray,\r\n    animations,\r\n){\r\n    if(startidx=== endidx) return;\r\n    const mididx= Math.floor((startidx+endidx)/2);\r\n    mergeSortHelper(auxarray,startidx,mididx,mainarray,animations);\r\n    mergeSortHelper(auxarray,mididx + 1,endidx,mainarray,animations);\r\n    domerge(mainarray,startidx,mididx,endidx,auxarray,animations);\r\n    \r\n}\r\n\r\nfunction domerge( //Method to sort the splitted arrays and merge them in sorted order\r\n    mainarray,\r\n    startidx,\r\n    mididx,\r\n    endidx,\r\n    auxarray,\r\n    animations,\r\n){\r\n    let i=startidx;\r\n    let j=mididx+1;\r\n    let k=startidx;\r\n    var comparisons = 0;  //No of comparisons\r\n\r\n    while(i<= mididx && j<=endidx){ //Comparing elements in the split arrays along with animation\r\n        animations.push([i,j]);\r\n        animations.push([i,j]);\r\n        comparisons++;\r\n\r\n        if(auxarray[i]<= auxarray[j]){  //Sorting the elements in the split arrays along with animation\r\n            animations.push([k, auxarray[i]]);\r\n            mainarray[k++]=auxarray[i++];\r\n        }\r\n        else{\r\n            animations.push([k, auxarray[j]]);\r\n            mainarray[k++]=auxarray[j++];\r\n        }\r\n    }\r\n\r\n    //Merging the arrays\r\n    while(i<=mididx){\r\n        animations.push([i,i]);\r\n        animations.push([i,i]);\r\n        comparisons++;\r\n\r\n        animations.push([k, auxarray[i]]);\r\n        mainarray[k++]=auxarray[i++];\r\n    }\r\n\r\n    while(j<=endidx){\r\n        animations.push([j,j]);\r\n        animations.push([j,j]);\r\n        comparisons++;\r\n\r\n        animations.push([k, auxarray[j]])\r\n        mainarray[k++]= auxarray[j++];\r\n    }\r\n\r\n    animations[-2] = comparisons;   //Pushing comparisons and swaps towards the end of the array\r\n                                    //Remember there are no swaps in mergesort only overwriting\r\n}\r\n\r\n","import React from 'react'; //imports\r\nimport './Sortingvisualizer.css';\r\nimport {mergeSort} from '../Algorithm-files/mergesort'; \r\nimport { bubbleSort } from '../Algorithm-files/bubblesort';\r\nimport Popup from '../../PopupComponent/Popup';\r\nvar bubblesorted = 0;\r\nvar mergesorted = 0;\r\n\r\nexport default class Sortingvis extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state={\r\n            array:[],           //main array of bars\r\n            duparray:[],        //Duplicate array to revert changes\r\n            popupstate:false,   //the state of our popup for the user manual\r\n        };\r\n    }\r\n\r\n    componentDidMount(){\r\n        this.resetArray(); //Generating a new array for first time load\r\n        document.getElementById('ogarr').disabled = true; //Disabling the get original array button initially\r\n    }\r\n\r\n    getoriginalArray() //Method to get the original unsorted array and render onto the screen\r\n    {\r\n        if(mergesorted === 1)   //If we have already used mergesort we are only allowed to bubble sort\r\n            document.getElementById(\"bbsort\").disabled = false;\r\n\r\n        if(bubblesorted === 1)  //If we have already used bubble sort we are only allowed to use mergesort\r\n            document.getElementById(\"mesort\").disabled = false;\r\n        \r\n       const array = this.state.duparray;   //Changing state of sorted array to our original unsorted array\r\n       var style,height; //Rendering onto screen by setting the appropriate height in the style component\r\n       this.setState({array:array});\r\n       const arraybars= document.getElementsByClassName(\"array-bar\");\r\n       for(let i=0;i<180;i++){\r\n           style = arraybars[i].style;\r\n           height = array[i];\r\n           style.height= `${height}px`;\r\n       }\r\n\r\n    }\r\n\r\n    resetArray() //Method to create array of 180 bars with random sizes between range 5-550 pixels\r\n    {\r\n        const array =[];\r\n        var duparray = []; //To revert back any changes made from swapping\r\n        for(let i=0;i<180;i++)\r\n        {\r\n            var num = randomint(5,550);\r\n            array.push(num);\r\n            duparray.push(num)\r\n        }\r\n        this.setState({array:array,duparray:duparray}); //Setting the state to the created array\r\n    }\r\n\r\n\r\n    changestate =() => //Method to change the state of the user manual popup\r\n    {\r\n        this.setState({popupstate: !this.state.popupstate});\r\n    }\r\n\r\n    disablebutton(buttonid) //Method to disable a button by its id\r\n    {\r\n        document.getElementById(buttonid).disabled = true;\r\n    }\r\n    \r\n    mergeSort(){\r\n\r\n    this.disablebutton('mesort');   //Disabling buttons during sorting\r\n    this.disablebutton('bbsort');\r\n    this.disablebutton('ogarr');\r\n    this.disablebutton('man');\r\n\r\n\r\n    const animations = mergeSort(this.state.array);  //Getting an sorted array of animations\r\n\r\n    document.getElementById('mscomp').innerHTML = animations[-2]; //Setting no of comparisons and swaps\r\n    document.getElementById('msswap').innerHTML = \"NIL\";\r\n\r\n    if(mergesorted !==1 && bubblesorted!==1) //Enabling buttons after the completion of the animations\r\n        setTimeout(function () { document.getElementById(\"ogarr\").disabled = false; }, (animations.length-2)*5);\r\n    setTimeout(function () { document.getElementById(\"man\").disabled = false; }, (animations.length-2)*5);\r\n    \r\n\r\n    mergesorted = 1; //Indicates mergesort has been performed\r\n\r\n    //The animations are in triplets 1- Comparison 2-Turn off previous animation 3-Swap\r\n\r\n    for(let i=0; i<animations.length-2; i++){  //Iterating through animation array\r\n        const arraybars= document.getElementsByClassName(\"array-bar\");\r\n        const colorchange = i%3 !==2; //If we are not required to swap (compsrison)\r\n        \r\n        if(colorchange){\r\n            const[bar1idx, bar2idx]= animations[i];\r\n            const bar1style= arraybars[bar1idx].style;\r\n            const bar2style= arraybars[bar2idx].style;\r\n            const color= i%3===0 ? 'red': 'black';  //Logic to change first animation to a different color then back\r\n            setTimeout(() => {  //Changing color with a timout decided based on the index (No swap)\r\n                bar1style.backgroundColor = color;\r\n                bar2style.backgroundColor = color;\r\n            } ,i * 5)\r\n        }\r\n        else    //Swapping logic with a timeout based on index\r\n        {\r\n            setTimeout(() => {\r\n                const [bar1idx, height] = animations[i];\r\n                const bar1style= arraybars[bar1idx].style;\r\n                bar1style.height= `${height}px`;\r\n            }, i * 5);\r\n        }\r\n    }\r\n\r\n   }\r\n\r\n    bubbleSort() {\r\n        \r\n        this.disablebutton('mesort');   //Disabling buttons during sorting\r\n        this.disablebutton('bbsort');\r\n        this.disablebutton('ogarr');\r\n        this.disablebutton('man');\r\n    \r\n        const animations = bubbleSort(this.state.array); //Getting an sorted array of animations\r\n\r\n        document.getElementById('bscomp').innerHTML = animations[-2];   //Setting no of comparisons and swaps\r\n        document.getElementById('bsswap').innerHTML = animations[-1];\r\n\r\n\r\n        if(mergesorted !==1 && bubblesorted!==1)    //Enabling buttons after the completion of the animations\r\n            setTimeout(function () { document.getElementById(\"ogarr\").disabled = false; }, (animations.length-2)*3);\r\n        setTimeout(function () { document.getElementById(\"man\").disabled = false; }, (animations.length-2)*3);\r\n\r\n\r\n        bubblesorted = 1 //Indicates bubble sort has been performed\r\n        \r\n        //The animations are in triplets 1- Comparison 2-Turn off previous animation 3-Swap\r\n        //The last two elements contain the number of comparisons and swaps\r\n\r\n        for(let i=0;i<animations.length-2; i++){  //Iterating through animation array\r\n            const arraybars= document.getElementsByClassName(\"array-bar\");\r\n            const colorchange = i%3!==2;//If we are not required to swap\r\n\r\n            if(colorchange){\r\n                const[bar1idx, bar2idx]= animations[i];\r\n                const bar1style= arraybars[bar1idx].style;\r\n                const bar2style= arraybars[bar2idx].style;\r\n                const color = i%3 === 0? 'red': 'black';    //Logic to change first animation to a different color then back\r\n                setTimeout(() => {  //Changing color with a timout decided based on the index (No swap)\r\n                    bar1style.backgroundColor = color;\r\n                    bar2style.backgroundColor = color;\r\n                } ,i * 3);\r\n            }\r\n            else{   //Swapping logic with a timeout based on index\r\n                const[bar1idx, bar2idx]= animations[i];\r\n                const bar1style= arraybars[bar1idx].style;\r\n                const bar2style= arraybars[bar2idx].style;\r\n                if(bar1idx!==bar2idx){  //If compared values are different\r\n                    setTimeout(() => {  //Changing the heights of the bars to show they are sorted\r\n                        const tempheight = bar1style.height;\r\n                        bar1style.height= bar2style.height;\r\n                        bar2style.height= tempheight;\r\n                    }, i * 3);\r\n                }\r\n                else{\r\n                    continue;\r\n                }\r\n            }\r\n    }\r\n}\r\n\r\nrender() {\r\n        const {array,duparray,popupstate}= this.state;   //setting initial states\r\n\r\n        return (\r\n            <div className=\"array-container\">\r\n\r\n                <h2>Sorting Visualizer<br></br></h2>\r\n                {array.map((value,idx) =>(      //Mapping the generated random array values onto the screen\r\n                    <div \r\n                     className=\"array-bar\"\r\n                     key={idx} \r\n                     style={{       //Styles to create the bars\r\n                        backgroundColor: 'black',\r\n                        height: `${value}px` ,\r\n                        }}></div>\r\n                \r\n                ))} \r\n                \r\n                <br></br><br></br>\r\n                <button id='bbsort' onClick={() => this.bubbleSort()}>Bubble Sort</button>\r\n                <button id='mesort' onClick={() => this.mergeSort()}>Merge Sort</button>\r\n                <button id='ogarr' onClick={()=> this.getoriginalArray()}>Get Original Array</button>\r\n                <button id='reset' onClick={() => window.location.reload(false)}>Reset Array</button>\r\n                <button id='man' onClick={this.changestate}>User manual</button>\r\n\r\n                <br/><br/>\r\n                <div className='sorting-metrics'>\r\n                    <table cellPadding={10}>\r\n                        <tr>\r\n                            <th>Bubble Sort</th>\r\n                            <td>Comparisons: </td><br/><br/>\r\n                            <td id='bscomp'></td><br/><br/>\r\n                            <td>Swaps: </td><br/><br/>\r\n                            <td id='bsswap'></td><br/><br/>\r\n                        </tr>\r\n                        <tr>\r\n                            <th>Merge Sort</th>\r\n                            <td>Comparisons: </td><br/><br/>\r\n                            <td id='mscomp'></td><br/><br/>\r\n                            <td>Swaps: </td><br/><br/>\r\n                            <td id='msswap'></td><br/><br/>\r\n                        </tr>\r\n                    </table>\r\n                </div>\r\n                \r\n                {this.state.popupstate ?        //Popup for the user manual\r\n                <Popup trigger={popupstate} handleclose = {this.changestate}>\r\n                    <h2>Sorting Visualizer Manual</h2>\r\n                    <p>Welcome, This is the sorting visualizer<br></br>\r\n                    You have bars of various heights covering your screen<br></br>\r\n                    They can be seen as an array with different numbers in them<br></br>\r\n                    By clicking the Reset Array button you can generate a new random combination of bars<br></br>\r\n                    Get Original Array button reverts to the original unsorted array so you can visualize and compare other algorithms on the same array<br/>\r\n                    When you click any of the algorithm buttons you see how the algorithm works visually<br></br>\r\n                    The bars arrange themselves in sorted order by using the algorihm you picked<br></br>\r\n                    Observe and learn how each algorithm works in depth<br></br>Enjoy</p>\r\n                </Popup>\r\n                :null}\r\n                \r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction randomint(min, max)  //Method to generate a random integer within an interval\r\n{\r\n    return Math.floor(Math.random()*(max-min+1)+min);\r\n}","export function bubbleSort(array){\r\n    var swaps = 0;  //No of swaps\r\n    var comparisons = 0;  //No of comparisons\r\n\r\n    const animations = [];  //Animations array\r\n    if(array.length<=1)return array;  //Single element array doesnt need to be sorted\r\n\r\n    for(let i=0 ; i<array.length; i++){ //Bubble sort\r\n        for(let j=0; j<array.length-i-1; j++){\r\n            animations.push([j,j+1]);   //Comparison animations\r\n            animations.push([j,j+1]);\r\n            comparisons ++;\r\n\r\n            if(array[j]>array[j+1]){ //Sorting along with animation\r\n                animations.push([j,j+1]);\r\n                swaps++;\r\n\r\n                const temp = array[j];\r\n                array[j] = array[j+1];\r\n                array[j+1] = temp;\r\n            }\r\n            else{\r\n                animations.push([j,j]);\r\n            }\r\n        } \r\n    }\r\n\r\n    animations[-2] = comparisons;   //Pushing comparisons and swaps towards the end of the array\r\n    animations[-1] = swaps;\r\n    return animations;\r\n}\r\n","import './App.css';\nimport React, {Component, useState} from 'react';\nimport {BrowserRouter as Router, Switch, Route} from 'react-router-dom';\nimport Home from './Home/home'\nimport Pathfinder from './PathfindingComponents/Pathfinder/pathfinder'\nimport Sortingvis from './SortingComponents/Sortingvisualizer/Sortingvisualizer';\nimport { Redirect } from 'react-router-dom/cjs/react-router-dom.min';\n\n\nfunction App() {\n\n  return (\n    <div className=\"App\">\n        Hi ur deployment failed\n        <Switch>\n          <Route exact path = \"/\">\n              <Redirect to= \"/home\"/>\n          </Route>\n          <Route exact path =\"/home\" component={Home} />\n          <Route exact path =\"/sorting\" component={Sortingvis} />\n          <Route exact path =\"/pathfinding\" component={Pathfinder} />\n        </Switch>\n        \n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {HashRouter as Router} from 'react-router-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Router>\n      <App />\n    </Router>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}